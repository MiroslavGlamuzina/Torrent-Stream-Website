{
  "name": "k-rpc",
  "version": "3.6.0",
  "description": "Low-level implementation of the k-rpc protocol used the BitTorrent DHT.",
  "main": "index.js",
  "dependencies": {
    "buffer-equals": "^1.0.3",
    "k-bucket": "^0.6.0",
    "k-rpc-socket": "^1.5.0"
  },
  "devDependencies": {
    "standard": "^5.4.1",
    "tape": "^4.4.0"
  },
  "scripts": {
    "test": "standard && tape test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mafintosh/k-rpc.git"
  },
  "author": {
    "name": "Mathias Buus",
    "url": "@mafintosh"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/k-rpc/issues"
  },
  "homepage": "https://github.com/mafintosh/k-rpc",
  "readme": "# k-rpc\n\nLow-level implementation of the k-rpc protocol used by the BitTorrent DHT.\n\n```\nnpm install k-rpc\n```\n\nRead [BEP 5](http://www.bittorrent.org/beps/bep_0005.html) and [BEP 44](http://www.bittorrent.org/beps/bep_0044.html) for more background info.\n\n[![build status](http://img.shields.io/travis/mafintosh/k-rpc.svg?style=flat)](http://travis-ci.org/mafintosh/k-rpc)\n\n## Usage\n\n``` js\nvar krpc = require('k-rpc')\nvar rpc = krpc()\n\nvar target = new Buffer('aaaabbbbccccddddeeeeffffaaaabbbbccccdddd', 'hex')\n\n// query the BitTorrent DHT to find nodes near the target buffer\nrpc.closest(target, {q: 'get_peers', a: {info_hash: target}}, onreply, done)\n\nfunction onreply (message, node) {\n  console.log('visited peer', message, node)\n}\n\nfunction done () {\n  console.log('(done)')\n}\n```\n\n## API\n\n#### `var rpc = krpc([options])`\n\nCreate a new rpc instance. Options include\n\n``` js\n{\n  // per peer query timeout defaults to 2s\n  timeout: 2000,\n  // an array of bootstrap nodes. defaults to the BitTorrent bootstrap nodes\n  nodes: ['example.com:6881'],\n  // how many concurrent queries should be made. defaults to 16\n  concurrency: 16,\n  // how big should be routing buckets be. defaults to 20.\n  k: 20,\n  // the local node id. defaults to 20 random bytes\n  id: Buffer(...)\n}\n```\n\n#### `rpc.id`\n\nBuffer containing the local node id.\n\n#### `rpc.nodes`\n\nRouting table populated by running `rpc.populate`. This is a [k-bucket](https://github.com/tristanls/k-bucket) instance.\n\n#### `rpc.populate(query, [callback])`\n\nPopulate the `rpc.nodes` routing table with nodes discovered by looking for other peers close to our own local node id using the specified query. The internal routing table will be used for subsequent closest queries to take load of the bootstrap nodes.\n\n``` js\n// send a find_node query\nrpc.populate(rpc.id, {q: 'find_node', a: {id: rpc.id, target: rpc.id}}, function () {\n  console.log('internal routing table fully populated')\n})\n```\n\nYou should call this method as soon as possible to spread out query load in the DHT.\nCallback is called with `(err, numberOfReplies)`.\n\n#### `rpc.closest(target, query, onreply, [callback])`\n\nFind peers close the specified target buffer whilst sending the specified query. `onreply` will be called with `(reply, node)` for every reply received and the callback is called with `(err, totalNumberOfReplies)`.\n\n``` js\n// find peers sharing a torrent info_hash\nrpc.closest(infoHash, {q: 'get_peers', a: {id: rpc.id: info_hash: infoHash}}, onreply, function () {\n  console.log('no more peers to be found')\n})\n\nfunction onreply (message, node) {\n  if (message.r && message.r.values) console.log('received peers')\n}\n```\n\nIf a closest query is being executed while a population request in being run the closest query will take priority.\n\nYou can return `false` from onreply to stop the query. This is useful if you are only looking for a single peer for example.\n\n``` js\nfunction onreply(message, node) {\n  console.log('will only fire once')\n  return false\n}\n```\n\n#### `rpc.query(node, query, callback)`\n\nQuery a single node. If the node has a token it is set as `a.token` in the query automatically.\nCallback is called with `(err, reply)`.\n\n#### `rpc.queryAll(nodes, query, onreply, callback)`\n\nQuery multiple nodes with the same query. `query.a.token` will be set as the corresponding nodes token when querying.\nCallback is called with `(err, numberOfReplies)` and `onreply` will be caleld with `(reply, node)` as the nodes reply.\n\n#### `rpc.destroy()`\n\nDestroy the underlying rpc socket.\n\n#### `rpc.on('query', query, node)`\n\nEmitted when a query is received.\n\n#### `rpc.response(node, query, response, [nodes], [callback])`\n\nSend a response to a node for a specific query. If you pass in an array of nodes `{id: nodeId, host: someHost, port: somePort}` they will be added to the response.\n\n#### `rpc.error(node, query, error, [callback])`\n\nSend an error response for a query.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "k-rpc@3.6.0",
  "_from": "k-rpc@^3.6.0"
}
