{
  "name": "k-rpc-socket",
  "version": "1.5.0",
  "description": "Low level implementation of the k-rpc network layer that the BitTorrent DHT uses",
  "main": "index.js",
  "dependencies": {
    "bencode": "^0.7.0"
  },
  "devDependencies": {
    "standard": "^5.4.1",
    "tape": "^4.4.0"
  },
  "scripts": {
    "test": "standard && tape test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mafintosh/k-rpc-socket.git"
  },
  "author": {
    "name": "Mathias Buus",
    "url": "@mafintosh"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/k-rpc-socket/issues"
  },
  "homepage": "https://github.com/mafintosh/k-rpc-socket",
  "readme": "# k-rpc-socket\n\nLow level implementation of the k-rpc network layer that the [BitTorrent DHT](http://www.bittorrent.org/beps/bep_0005.html) uses.\nMostly extracted from the [bittorrent-dht](https://github.com/feross/bittorrent-dht) module on npm into its own repo.\n\n```\nnpm install k-rpc-socket\n```\n\n[![build status](http://img.shields.io/travis/mafintosh/k-rpc-socket.svg?style=flat)](http://travis-ci.org/mafintosh/k-rpc-socket)\n\n## Usage\n\n``` js\nvar rpc = require('k-rpc-socket')\n\nvar socket = rpc()\n\nsocket.on('query', function (query, peer) {\n  socket.response(peer, query, {echo: query.a})\n})\n\nsocket.bind(10000, function () {\n  var anotherSocket = rpc()\n  anotherSocket.query({host: '127.0.0.1', port: 10000}, {hello: 'world'}, function (err, response) {\n    console.log(response.r) // prints {echo: {hello: Buffer('world')}}\n  })\n})\n```\n\n## API\n\n#### `var socket = rpc([options])`\n\nCreate a new k-rpc-socket. Options include:\n\n``` js\n{\n  timeout: queryTimeout, // defaults to 2s\n  socket: optionalUdpSocket\n}\n```\n\n#### `socket.send(peer, message, [callback])`\n\nSend a raw message. The callback is called when the message has been flushed from the socket.\n\n#### `var id = socket.query(peer, query, [callback])`\n\nSend a query message. The callback is called with `(err, response, peer, request)`.\nYou should set the method name you are trying to call as `{q: 'method_name'}` and query data as `{a: someQueryData}`.\n\nThe query method returns a query id. You can use this id to cancel the query using the `.cancel` method.\n\n#### `socket.cancel(id)`\n\nCancel a query. Will call the corresponding query's callback with an error indicating that it was cancelled.\n\n#### `socket.response(peer, query, response, [callback])`\n\nSend a response to a query. The callback is called when the message has been flushed from the socket.\n\n#### `socket.error(peer, query, error, [callback])`\n\nSend an error reploy to a query. The callback is called when the message has been flushed from the socket.\n\n#### `socket.inflight`\n\nInteger representing the number of concurrent queries that are currently pending.\n\n#### `socket.destroy()`\n\nDestroys and unbinds the socket\n\n#### `socket.bind(port, callback)`\n\nCall this to bind to a specific port. If you don't call this a random free port will be chosen.\n\n#### `socket.on('query', query, peer)`\n\nWhen a query is received a `query` event is emitted with the query data and a peer object representing the querying peer.\n\n#### `socket.on('warning', error)`\n\nEmitted when a non fatal error has occured. It is safe to ignore this.\n\n#### `socket.on('error', error)`\n\nEmitted when a fatal error has occured.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "k-rpc-socket@1.5.0",
  "_from": "k-rpc-socket@^1.5.0"
}
